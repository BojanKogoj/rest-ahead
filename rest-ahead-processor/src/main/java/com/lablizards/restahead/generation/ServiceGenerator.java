package com.lablizards.restahead.generation;

import com.lablizards.restahead.client.RestClient;
import com.lablizards.restahead.conversion.Converter;
import com.lablizards.restahead.modeling.declaration.ServiceDeclaration;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import javax.annotation.processing.Filer;
import javax.annotation.processing.Generated;
import javax.annotation.processing.Messager;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import java.io.IOException;
import java.util.List;

/**
 * Used to generate implementation for services.
 */
public class ServiceGenerator {
    private final Messager messager;
    private final Filer filer;
    private final MethodGenerator methodGenerator;

    /**
     * Default constructor.
     *
     * @param messager the messager where info, errors etc. should be reported
     * @param filer    the filer to use when writing generated files
     */
    public ServiceGenerator(Messager messager, Filer filer) {
        this.messager = messager;
        this.filer = filer;
        this.methodGenerator = new MethodGenerator();
    }

    /**
     * Generate the service implementation.
     *
     * @param serviceDeclaration the interface declaration to conform to
     */
    public void generateService(ServiceDeclaration serviceDeclaration) {
        var methods = methodGenerator.generateMethods(serviceDeclaration.calls());

        var generatedAnnotation = createGeneratedAnnotation();

        var type = generateTypeSpecification(
            serviceDeclaration.generatedName(),
            serviceDeclaration.serviceType(),
            serviceDeclaration.requiresConverter(),
            generatedAnnotation,
            methods
        );

        var packageName = serviceDeclaration.packageName();
        var javaFile = JavaFile.builder(packageName, type)
            .indent("    ")
            .build();

        try {
            javaFile.writeTo(filer);
            messager.printMessage(Diagnostic.Kind.NOTE, "Generated " + type.name);
        } catch (IOException e) {
            messager.printMessage(Diagnostic.Kind.ERROR, "Unable to write class: " + e.getMessage());
        }
    }

    /**
     * Generate the type specification.
     *
     * @param typeName            the name for generated service
     * @param serviceDeclaration  the interface containing annotated methods
     * @param requiresConverter   whether the generated service needs a converter
     * @param generatedAnnotation the generated annotation to add to implementation
     * @param methods             the methods to attach to generated class
     * @return the generated class
     */
    private TypeSpec generateTypeSpecification(
        String typeName,
        TypeElement serviceDeclaration,
        boolean requiresConverter,
        AnnotationSpec generatedAnnotation,
        List<MethodSpec> methods
    ) {
        var builder = TypeSpec.classBuilder(typeName)
            .addSuperinterface(serviceDeclaration.asType())
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addAnnotation(generatedAnnotation)
            .addMethods(methods)
            .addField(createClientField())
            .addMethod(createConstructor(requiresConverter));
        if (requiresConverter) {
            messager.printMessage(Diagnostic.Kind.NOTE, serviceDeclaration + " requires a converter, adding field.");
            builder.addField(createConverterField());
        }

        return builder.build();
    }

    /**
     * Creates the @Generated annotation
     *
     * @return the generated annotation with a comment
     */
    private AnnotationSpec createGeneratedAnnotation() {
        return AnnotationSpec.builder(Generated.class)
            .addMember("value", "$S", "Generated by RestAhead")
            .build();
    }

    /**
     * Creates the client field.
     *
     * @return field specification for client
     */
    private FieldSpec createClientField() {
        return FieldSpec.builder(RestClient.class, "client", Modifier.PRIVATE, Modifier.FINAL)
            .build();
    }

    private FieldSpec createConverterField() {
        return FieldSpec.builder(Converter.class, "converter", Modifier.PRIVATE, Modifier.FINAL)
            .build();
    }

    /**
     * Creates the constructor for the service.
     *
     * @return the constructor specification.
     */
    private MethodSpec createConstructor(boolean hasCustomTypes) {
        var builder = MethodSpec.constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addParameter(RestClient.class, "client")
            .addStatement("this.client = client");

        if (hasCustomTypes) {
            builder.addParameter(Converter.class, "converter")
                .addStatement("this.converter = converter");
        }

        return builder.build();
    }
}
