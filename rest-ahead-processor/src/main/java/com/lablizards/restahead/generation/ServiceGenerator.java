package com.lablizards.restahead.generation;

import com.lablizards.restahead.client.RestClient;
import com.lablizards.restahead.conversion.Converter;
import com.lablizards.restahead.modeling.declaration.AdapterClassDeclaration;
import com.lablizards.restahead.modeling.declaration.ServiceDeclaration;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import javax.annotation.processing.Filer;
import javax.annotation.processing.Generated;
import javax.annotation.processing.Messager;
import javax.lang.model.element.Modifier;
import javax.tools.Diagnostic;
import java.io.IOException;
import java.util.List;

/**
 * Used to generate implementation for services.
 */
public class ServiceGenerator {
    private static final String FIELD_ASSIGNMENT = "this.$L = $L";

    private final Messager messager;
    private final Filer filer;
    private final MethodGenerator methodGenerator;

    /**
     * Default constructor.
     *
     * @param messager the messager where info, errors etc. should be reported
     * @param filer    the filer to use when writing generated files
     */
    public ServiceGenerator(Messager messager, Filer filer) {
        this.messager = messager;
        this.filer = filer;
        this.methodGenerator = new MethodGenerator();
    }

    /**
     * Generate the service implementation.
     *
     * @param serviceDeclaration the interface declaration to conform to
     */
    public void generateService(ServiceDeclaration serviceDeclaration) {
        var methods = methodGenerator.generateMethods(serviceDeclaration.calls());

        var generatedAnnotation = createGeneratedAnnotation();

        var type = generateTypeSpecification(
            serviceDeclaration,
            generatedAnnotation,
            methods
        );

        var packageName = serviceDeclaration.packageName();
        var javaFile = JavaFile.builder(packageName, type)
            .indent("    ")
            .build();

        try {
            javaFile.writeTo(filer);
            messager.printMessage(Diagnostic.Kind.NOTE, "Generated " + type.name);
        } catch (IOException e) {
            messager.printMessage(Diagnostic.Kind.ERROR, "Unable to write class: " + e.getMessage());
        }
    }

    /**
     * Generate the type specification.
     *
     * @param serviceDeclaration  the declaration of service to implement
     * @param generatedAnnotation the generated annotation to add to implementation
     * @param methods             the methods to attach to generated class
     * @return the generated class
     */
    private TypeSpec generateTypeSpecification(
        ServiceDeclaration serviceDeclaration,
        AnnotationSpec generatedAnnotation,
        List<MethodSpec> methods
    ) {
        var builder = TypeSpec.classBuilder(serviceDeclaration.generatedName())
            .addSuperinterface(serviceDeclaration.serviceType().asType())
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addAnnotation(generatedAnnotation)
            .addMethods(methods)
            .addField(createClientField())
            .addMethod(createConstructor(serviceDeclaration.requiresConverter(), serviceDeclaration.requiredAdapters()));
        if (serviceDeclaration.requiresConverter()) {
            builder.addField(createConverterField());
        }
        serviceDeclaration.requiredAdapters()
            .forEach(adapter -> {
                var field = FieldSpec.builder(
                    TypeName.get(adapter.adapterType().asType()),
                    adapter.variableName(),
                    Modifier.PRIVATE, Modifier.FINAL
                ).build();
                builder.addField(field);
            });

        return builder.build();
    }

    /**
     * Creates the @Generated annotation
     *
     * @return the generated annotation with a comment
     */
    private AnnotationSpec createGeneratedAnnotation() {
        return AnnotationSpec.builder(Generated.class)
            .addMember("value", "$S", "Generated by RestAhead")
            .build();
    }

    /**
     * Creates the client field.
     *
     * @return field specification for client
     */
    private FieldSpec createClientField() {
        return FieldSpec.builder(RestClient.class, Variables.CLIENT, Modifier.PRIVATE, Modifier.FINAL)
            .build();
    }

    /**
     * Creates the converter field.
     *
     * @return field specification for a converter
     */
    private FieldSpec createConverterField() {
        return FieldSpec.builder(Converter.class, Variables.CONVERTER, Modifier.PRIVATE, Modifier.FINAL)
            .build();
    }

    /**
     * Creates the constructor for the service.
     *
     * @param hasCustomTypes whether the converter needs to be added
     * @param adapters       the list of adapters that needs to be added
     * @return the constructor specification.
     */
    private MethodSpec createConstructor(
        boolean hasCustomTypes,
        List<AdapterClassDeclaration> adapters
    ) {
        var builder = MethodSpec.constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addParameter(RestClient.class, Variables.CLIENT)
            .addStatement(FIELD_ASSIGNMENT, Variables.CLIENT, Variables.CLIENT);

        if (hasCustomTypes) {
            builder.addParameter(Converter.class, Variables.CONVERTER)
                .addStatement(FIELD_ASSIGNMENT, Variables.CONVERTER, Variables.CONVERTER);
        }
        adapters.forEach(adapter -> builder.addParameter(TypeName.get(adapter.adapterType().asType()), adapter.variableName())
            .addStatement(FIELD_ASSIGNMENT, adapter.variableName(), adapter.variableName()));

        return builder.build();
    }
}
